// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRPFD_TITAN_FILESYSTEM_H_
#define FLATBUFFERS_GENERATED_TRPFD_TITAN_FILESYSTEM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace FileSystem {

struct EmptyTable;
struct EmptyTableBuilder;

struct FileInfo;
struct FileInfoBuilder;

struct Packinfo;
struct PackinfoBuilder;

struct TRPFD;
struct TRPFDBuilder;

struct EmptyTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyTableBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyTableBuilder {
  typedef EmptyTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EmptyTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmptyTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmptyTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmptyTable> CreateEmptyTable(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyTableBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FileInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACK_INDEX = 4,
    VT_UNK_1 = 6
  };
  uint64_t pack_index() const {
    return GetField<uint64_t>(VT_PACK_INDEX, 0);
  }
  const Titan::FileSystem::EmptyTable *unk_1() const {
    return GetPointer<const Titan::FileSystem::EmptyTable *>(VT_UNK_1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACK_INDEX, 8) &&
           VerifyOffset(verifier, VT_UNK_1) &&
           verifier.VerifyTable(unk_1()) &&
           verifier.EndTable();
  }
};

struct FileInfoBuilder {
  typedef FileInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pack_index(uint64_t pack_index) {
    fbb_.AddElement<uint64_t>(FileInfo::VT_PACK_INDEX, pack_index, 0);
  }
  void add_unk_1(::flatbuffers::Offset<Titan::FileSystem::EmptyTable> unk_1) {
    fbb_.AddOffset(FileInfo::VT_UNK_1, unk_1);
  }
  explicit FileInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FileInfo> CreateFileInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pack_index = 0,
    ::flatbuffers::Offset<Titan::FileSystem::EmptyTable> unk_1 = 0) {
  FileInfoBuilder builder_(_fbb);
  builder_.add_pack_index(pack_index);
  builder_.add_unk_1(unk_1);
  return builder_.Finish();
}

struct Packinfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackinfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_SIZE = 4,
    VT_FILE_COUNT = 6
  };
  uint64_t file_size() const {
    return GetField<uint64_t>(VT_FILE_SIZE, 0);
  }
  uint64_t file_count() const {
    return GetField<uint64_t>(VT_FILE_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FILE_SIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_FILE_COUNT, 8) &&
           verifier.EndTable();
  }
};

struct PackinfoBuilder {
  typedef Packinfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file_size(uint64_t file_size) {
    fbb_.AddElement<uint64_t>(Packinfo::VT_FILE_SIZE, file_size, 0);
  }
  void add_file_count(uint64_t file_count) {
    fbb_.AddElement<uint64_t>(Packinfo::VT_FILE_COUNT, file_count, 0);
  }
  explicit PackinfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Packinfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Packinfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Packinfo> CreatePackinfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_size = 0,
    uint64_t file_count = 0) {
  PackinfoBuilder builder_(_fbb);
  builder_.add_file_count(file_count);
  builder_.add_file_size(file_size);
  return builder_.Finish();
}

struct TRPFD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRPFDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_HASHES = 4,
    VT_PACK_STRINGS = 6,
    VT_FILES = 8,
    VT_PACKS = 10
  };
  const ::flatbuffers::Vector<uint64_t> *file_hashes() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_FILE_HASHES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *pack_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PACK_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>> *files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>> *>(VT_FILES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>> *packs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>> *>(VT_PACKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_HASHES) &&
           verifier.VerifyVector(file_hashes()) &&
           VerifyOffset(verifier, VT_PACK_STRINGS) &&
           verifier.VerifyVector(pack_strings()) &&
           verifier.VerifyVectorOfStrings(pack_strings()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyOffset(verifier, VT_PACKS) &&
           verifier.VerifyVector(packs()) &&
           verifier.VerifyVectorOfTables(packs()) &&
           verifier.EndTable();
  }
};

struct TRPFDBuilder {
  typedef TRPFD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file_hashes(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> file_hashes) {
    fbb_.AddOffset(TRPFD::VT_FILE_HASHES, file_hashes);
  }
  void add_pack_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pack_strings) {
    fbb_.AddOffset(TRPFD::VT_PACK_STRINGS, pack_strings);
  }
  void add_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>>> files) {
    fbb_.AddOffset(TRPFD::VT_FILES, files);
  }
  void add_packs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>>> packs) {
    fbb_.AddOffset(TRPFD::VT_PACKS, packs);
  }
  explicit TRPFDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRPFD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRPFD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRPFD> CreateTRPFD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> file_hashes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pack_strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>>> files = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>>> packs = 0) {
  TRPFDBuilder builder_(_fbb);
  builder_.add_packs(packs);
  builder_.add_files(files);
  builder_.add_pack_strings(pack_strings);
  builder_.add_file_hashes(file_hashes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRPFD> CreateTRPFDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *file_hashes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *pack_strings = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>> *files = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>> *packs = nullptr) {
  auto file_hashes__ = file_hashes ? _fbb.CreateVector<uint64_t>(*file_hashes) : 0;
  auto pack_strings__ = pack_strings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*pack_strings) : 0;
  auto files__ = files ? _fbb.CreateVector<::flatbuffers::Offset<Titan::FileSystem::FileInfo>>(*files) : 0;
  auto packs__ = packs ? _fbb.CreateVector<::flatbuffers::Offset<Titan::FileSystem::Packinfo>>(*packs) : 0;
  return Titan::FileSystem::CreateTRPFD(
      _fbb,
      file_hashes__,
      pack_strings__,
      files__,
      packs__);
}

inline const Titan::FileSystem::TRPFD *GetTRPFD(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::FileSystem::TRPFD>(buf);
}

inline const Titan::FileSystem::TRPFD *GetSizePrefixedTRPFD(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::FileSystem::TRPFD>(buf);
}

inline bool VerifyTRPFDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::FileSystem::TRPFD>(nullptr);
}

inline bool VerifySizePrefixedTRPFDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::FileSystem::TRPFD>(nullptr);
}

inline void FinishTRPFDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::FileSystem::TRPFD> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRPFDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::FileSystem::TRPFD> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FileSystem
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRPFD_TITAN_FILESYSTEM_H_
